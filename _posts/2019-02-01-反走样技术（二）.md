---
layout: post
title: "åèµ°æ ·æŠ€æœ¯ï¼ˆäºŒï¼‰"
subtitle: "åŸºäºå½¢æ€å­¦çš„æ–¹æ³• FXAA"
cover: "/assets/img/webgl/quaternion.jpg"
date:   2019-02-01
category: coding
tags: WebGL
author: xiaOp
comments: true
index: 73
---


* ã€ŒNvidia åŸç‰ˆ FXAA_WhitePaper.pdfã€[ğŸ”—](https://developer.download.nvidia.com/assets/gamedev/files/sdk/11/FXAA_WhitePaper.pdf)
* [åèµ°æ ·æŠ€æœ¯æ€»ç»“](https://zhuanlan.zhihu.com/p/28800047)
* ã€ŒImplementing FXAAã€[ğŸ”—](http://blog.simonrodriguez.fr/articles/30-07-2016_implementing_fxaa.html)
* [Three.js FXAAShader.js](https://github.com/mrdoob/three.js/blob/master/examples/js/shaders/FXAAShader.js)

æ¨èé˜…è¯»ã€ŒImplementing FXAAã€ï¼Œç›¸è¾ƒ nvidia åŸç‰ˆä»¥åŠ Three.js çš„å®ç°å¯è¯»æ€§è¦é«˜å¾ˆå¤šã€‚
å…¶ä»–å®ç°è¿˜æœ‰ clay.gl ä¸­çš„ [fxaa3.glsl]ï¼ˆhttps://github.com/pyalot/webgl-deferred-irradiance-volumes/blob/master/src/antialias/fxaa3_11_preprocessed.shaderlibï¼‰

## ç®—æ³•æ€è·¯

FXAA å’Œ MLAA ä»¥åŠ SMAA ä¸€æ ·ï¼Œéƒ½æ˜¯åŸºäºå‡ ä½•åèµ°æ ·çš„æ–¹æ³•ï¼ŒåŸºæœ¬æ­¥éª¤æ¥è‡ªåŸå§‹è®ºæ–‡ï¼Œå¯¹åº”ä¸‹é¢çš„ 8 å¼ å›¾ï¼š
1. non-linear RGB è¾“å…¥
1. åŸºäºäº®åº¦çš„è¾¹ç¼˜æ£€æµ‹ï¼Œçº¢è‰²éƒ¨åˆ†
1. æ£€æµ‹åˆ°çš„è¾¹ç¼˜æŒ‰æ°´å¹³å’Œå‚ç›´æ–¹å‘è¿›è¡Œåˆ†ç±»
1. Given edge orientation, the highest contrast pixel pair 90 degrees to the edge is
selected, in blue/green
1. æ²¿è¾¹ç¼˜æ–¹å‘å‘ä¸¤ä¾§ï¼ˆçº¢è‰²ä»£è¡¨è´Ÿå‘ï¼Œè“è‰²æ­£å‘ï¼‰æ£€æµ‹ï¼Œæ‰¾åˆ°äº®åº¦å˜åŒ–å¤§çš„ä¸€ç«¯
1. Given the ends of the edge, pixel position on the edge is transformed into to a
sub-pixel shift 90 degrees perpendicular to the edge to reduce the aliasing,
red/blue for -/+ horizontal shift and gold/skyblue for -/+ vertical shift
1. The input texture is re-sampled given this sub-pixel offset
1. ä½¿ç”¨ä¸€ä¸ªä½é€šæ»¤æ³¢å™¨è¿›è¡Œæ¨¡ç³Šå¤„ç†

![å±å¹•å¿«ç…§ 2019-02-02 ä¸Šåˆ11.39.36.png](https://intranetproxy.alipay.com/skylark/lark/0/2019/png/158945/1549078818327-64dacb4f-e4aa-49a6-9256-6c8a02a95bce.png#align=left&display=inline&height=375&linkTarget=_blank&name=%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-02%20%E4%B8%8A%E5%8D%8811.39.36.png&originHeight=720&originWidth=1432&size=1761141&width=746)

ä¸‹é¢ç»“åˆå…·ä½“å®ç°ã€‚

## è¾¹ç¼˜æ£€æµ‹
å’Œ MLAA & SMAA ä¸€æ ·ï¼Œé¦–å…ˆéœ€è¦æ£€æµ‹è¾¹ç¼˜ã€‚
> ä¸ºäº†æ›´å¥½çš„é€šç”¨æ€§ï¼ŒFXAA ä½¿ç”¨ sRGB ç©ºé—´çš„é¢œè‰²ä½œä¸ºè¾“å…¥ï¼Œå¹¶æ ¹æ®å±€éƒ¨çš„äº®åº¦å¯¹æ¯”åº¦æ¥ç¡®å®šä¸€ä¸ªåƒç´ æ˜¯å¦æ˜¯è¾¹ç¼˜åƒç´ ã€‚è¿™ä¹Ÿå°±æ˜¯è¡¨ç¤º FXAA ä¸€èˆ¬åº”è¯¥å‘ç”Ÿåœ¨ Tone Mapping ä¹‹åï¼Œæˆ–è€…ä¹Ÿå¯ä»¥æŠŠ Tone Mapping å’Œ FXAA æ•´åˆæˆä¸€ä¸ª passã€‚

RGB æå–äº®åº¦ï¼Œä¹‹å‰åœ¨ HDR Tone Mapping ä¸­å·²ç»ä»‹ç»è¿‡äº†ã€‚å¦å¤–éœ€è¦æ³¨æ„ï¼Œè¿™é‡Œè¿›è¡Œäº† gamma æ ¡æ­£è½¬æ¢åˆ° sRGB ç©ºé—´ï¼Œè™½ç„¶åªæ˜¯ä¼°ç®—ï¼ˆsqrt çº¦ç­‰äº pow(1/2.2)ï¼‰ï¼š
{% prism glsl linenos %}
float rgb2luma(vec3 rgb){
    return sqrt(dot(rgb, vec3(0.299, 0.587, 0.114)));
}
{% endprism %}

è¾¹ç¼˜æ£€æµ‹éƒ¨åˆ†å¾ˆç®€å•ï¼š
{% prism glsl linenos %}
vec3 colorCenter = texture(screenTexture,In.uv).rgb;

// å½“å‰ fragmentäº®åº¦
float lumaCenter = rgb2luma(colorCenter);

// ä¸Šä¸‹å·¦å³å››ä¸ªé‚»å±…äº®åº¦
float lumaDown = rgb2luma(textureOffset(screenTexture,In.uv,ivec2(0,-1)).rgb);
float lumaUp = rgb2luma(textureOffset(screenTexture,In.uv,ivec2(0,1)).rgb);
float lumaLeft = rgb2luma(textureOffset(screenTexture,In.uv,ivec2(-1,0)).rgb);
float lumaRight = rgb2luma(textureOffset(screenTexture,In.uv,ivec2(1,0)).rgb);

// æ‰¾åˆ°æœ€å¤§æœ€å°å€¼
float lumaMin = min(lumaCenter,min(min(lumaDown,lumaUp),min(lumaLeft,lumaRight)));
float lumaMax = max(lumaCenter,max(max(lumaDown,lumaUp),max(lumaLeft,lumaRight)));

// è®¡ç®—å·®å€¼
float lumaRange = lumaMax - lumaMin;

// ä½äºé˜ˆå€¼ï¼Œè·³è¿‡åç»­ FXAA å¤„ç†
if(lumaRange < max(EDGE_THRESHOLD_MIN,lumaMax*EDGE_THRESHOLD_MAX)){
    fragColor = colorCenter;
    return;
}
{% endprism %}

## è¾¹ç¼˜å½¢æ€
ç›¸è¾ƒ MLAA å¤šè¾¾ 16 ç§çš„è¾¹ç¼˜å½¢æ€ï¼Œè¾¹ç¼˜å½¢æ€åªç®€å•è€ƒè™‘æ°´å¹³å’Œå‚ç›´ä¸¤ç§ï¼š<br />ä¾‹å¦‚ horizontal:Â `|(upleft - left) - (left - downleft)| + 2 *Â |(up - center) - (center - down)| + |(upright - right) - (right - downright)|`
{% prism glsl linenos %}
// å¯¹è§’çº¿
float lumaDownLeft = rgb2luma(textureOffset(screenTexture,In.uv,ivec2(-1,-1)).rgb);
float lumaUpRight = rgb2luma(textureOffset(screenTexture,In.uv,ivec2(1,1)).rgb);
float lumaUpLeft = rgb2luma(textureOffset(screenTexture,In.uv,ivec2(-1,1)).rgb);
float lumaDownRight = rgb2luma(textureOffset(screenTexture,In.uv,ivec2(1,-1)).rgb);

// æ°´å¹³å‚ç›´æ–¹å‘
float lumaDownUp = lumaDown + lumaUp;
float lumaLeftRight = lumaLeft + lumaRight;

// 4ä¸ªè§’
float lumaLeftCorners = lumaDownLeft + lumaUpLeft;
float lumaDownCorners = lumaDownLeft + lumaDownRight;
float lumaRightCorners = lumaDownRight + lumaUpRight;
float lumaUpCorners = lumaUpRight + lumaUpLeft;

// æ°´å¹³å‚ç›´æ–¹å‘è®¡ç®—å·®å€¼
float edgeHorizontal =  abs(-2.0 * lumaLeft + lumaLeftCorners)  + abs(-2.0 * lumaCenter + lumaDownUp ) * 2.0    + abs(-2.0 * lumaRight + lumaRightCorners);
float edgeVertical =    abs(-2.0 * lumaUp + lumaUpCorners)      + abs(-2.0 * lumaCenter + lumaLeftRight) * 2.0  + abs(-2.0 * lumaDown + lumaDownCorners);

// åˆ¤æ–­æ–¹å‘ï¼Œæ°´å¹³ or å‚ç›´
bool isHorizontal = (edgeHorizontal >= edgeVertical);
{% endprism %}

ç”±äºè¾¹ç¼˜å¯èƒ½ç»è¿‡åƒç´ ä¸¤ä¾§ï¼ˆå·¦å³ï¼Œä¸Šä¸‹ï¼‰ï¼Œéœ€è¦è¿›ä¸€æ­¥åˆ¤æ–­ï¼š
{% prism glsl linenos %}
// ä¸¤ä¾§é‚»å±…
float luma1 = isHorizontal ? lumaDown : lumaLeft;
float luma2 = isHorizontal ? lumaUp : lumaRight;
// å½“å‰æ–¹å‘ä¸Šçš„å·®å€¼
float gradient1 = luma1 - lumaCenter;
float gradient2 = luma2 - lumaCenter;

// å“ªè¾¹å·®å€¼æ›´å¤§ï¼Ÿ
bool is1Steepest = abs(gradient1) >= abs(gradient2);

// ä½œä¸ºé˜ˆå€¼ä¾›åç»­æŸ¥æ‰¾ç«¯ç‚¹æ—¶ä½¿ç”¨
float gradientScaled = 0.25*max(abs(gradient1),abs(gradient2));

// çº¹ç´ å°ºå¯¸
float stepLength = isHorizontal ? inverseScreenSize.y : inverseScreenSize.x;

// å¹³å‡äº®åº¦
float lumaLocalAverage = 0.0;

if(is1Steepest){
    // åå‘
    stepLength = - stepLength;
    lumaLocalAverage = 0.5*(luma1 + lumaCenter);
} else {
    lumaLocalAverage = 0.5*(luma2 + lumaCenter);
}

// æ²¿è¾¹ç¼˜æ–¹å‘ç§»åŠ¨åŠä¸ªçº¹ç´ 
vec2 currentUv = In.uv;
if(isHorizontal){
    currentUv.y += stepLength * 0.5;
} else {
    currentUv.x += stepLength * 0.5;
}
{% endprism %}

ä¾‹å¦‚å½“å‰ fragment åœ¨çº¢åœˆå¤„ï¼Œç°åœ¨æˆ‘ä»¬æ‰¾åˆ°äº† currentUvï¼ˆç»¿å‰å¤„ï¼‰<br />![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2019/png/158945/1549023896931-7321d4d7-2e7e-4bab-9c7a-e8513c925d2a.png#align=left&display=inline&height=253&linkTarget=_blank&name=image.png&originHeight=956&originWidth=1452&size=40212&width=385)<br />ä¸‹ä¸€æ­¥éœ€è¦æ‰¾åˆ°è¾¹ç¼˜çš„é¦–å°¾ã€‚

## æŸ¥æ‰¾çº¿æ®µç«¯ç‚¹
è¿™ä¸€æ­¥ç›¸è¾ƒ MLAA å°±æ›´ç®€å•äº†ï¼Œä¸éœ€è¦è€ƒè™‘ crossing edge çš„å¤šç§å½¢æ€ï¼Œåªéœ€è¦æ²¿è¾¹ç¼˜æ–¹å‘å‘ä¸¤ä¾§æŸ¥æ‰¾ï¼š
{% prism glsl linenos %}
// ä¸€ä¸ªçº¹ç´ åç§»é‡
vec2 offset = isHorizontal ? vec2(inverseScreenSize.x,0.0) : vec2(0.0,inverseScreenSize.y);
// å½“å‰è¾¹ç¼˜ç‚¹ä¸¤ä¾§
vec2 uv1 = currentUv - offset;
vec2 uv2 = currentUv + offset;

// ä¸¤ä¾§äº®åº¦ä¸å‡å€¼çš„å·®å€¼
float lumaEnd1 = rgb2luma(texture(screenTexture,uv1).rgb);
float lumaEnd2 = rgb2luma(texture(screenTexture,uv2).rgb);
lumaEnd1 -= lumaLocalAverage;
lumaEnd2 -= lumaLocalAverage;

// å¤§äºè¯¥æ–¹å‘ä¸Šçš„é˜ˆå€¼ï¼Œè®¤ä¸ºåˆ°è¾¾äº†è¾¹ç¼˜çš„ç«¯ç‚¹å¤„
bool reached1 = abs(lumaEnd1) >= gradientScaled;
bool reached2 = abs(lumaEnd2) >= gradientScaled;
bool reachedBoth = reached1 && reached2;

// æ²¡æœ‰åˆ°è¾¾è¾¹ç¼˜ï¼Œç»§ç»­å‘ä¸¤ä¾§æŸ¥æ‰¾
if(!reached1){
    uv1 -= offset;
}
if(!reached2){
    uv2 += offset;
}
{% endprism %}

GLSL ä¸­å¹¶ä¸æ”¯æŒé€’å½’ï¼Œå› æ­¤åªèƒ½é€šè¿‡æœ‰é™æ¬¡çš„å¾ªç¯å®ç°ï¼Œä¸ºäº†æå‡æŸ¥æ‰¾æ•ˆç‡ï¼Œä¼šé€æ¸åŠ å¤§åç§»é‡çš„æ­¥é•¿ QUALITYã€‚å¦å¤–ï¼Œå¦‚æœä¸ä½¿ç”¨ for å¾ªç¯çš„è¯ä¹Ÿå¯ä»¥åµŒå¥—å¤šå±‚ï¼Œfxaa3.glsl ä¸­å°±æ˜¯è¿™ä¹ˆå®ç°çš„ã€‚
{% prism glsl linenos %}
if(!reachedBoth){
    for(int i = 2; i < ITERATIONS; i++){
 			  // çœç•¥æ£€æµ‹ä»£ç ï¼ŒåŒä¸Š
        // QUALITY 5æ¬¡ä¹‹åä¼šå¢åŠ ï¼Œä¾‹å¦‚ 1.5, 2.0...
        if(!reached1){
            uv1 -= offset * QUALITY(i);
        }
        if(!reached2){
            uv2 += offset * QUALITY(i);
        }
        // åˆ°è¾¾ç«¯ç‚¹è·³å‡º
        if(reachedBoth){ break; }
    }
}
{% endprism %}

ç°åœ¨æˆ‘ä»¬æ‰¾åˆ°äº†çº¿æ®µçš„ç«¯ç‚¹ï¼ˆè“è‰²ï¼‰uv1 uv2ï¼š<br />![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2019/png/158945/1549024921691-090581b5-aec3-45a3-bc21-e8d6ec6af97c.png#align=left&display=inline&height=248&linkTarget=_blank&name=image.png&originHeight=956&originWidth=1452&size=42598&width=377)

## æ··åˆ
æ‰¾åˆ°ç«¯ç‚¹åï¼Œéœ€è¦çŸ¥é“Â currentUv ç¦»å“ªä¸ªç«¯ç‚¹æ›´è¿‘ï¼Œä»¥åŠçº¿æ®µæ€»é•¿åº¦ã€‚è¿™æ ·å°±å¯ä»¥è®¡ç®—å‡ºè¦†ç›–ç‡ï¼Œæœ¬è´¨ä¸Šå°±æ˜¯ä¸€ä¸ªçº¿æ€§æ’å€¼æ¸å˜çš„è¿‡ç¨‹ï¼š
{% prism glsl linenos %}
// ä¸¤ä¾§çº¿æ®µé•¿åº¦
float distance1 = isHorizontal ? (In.uv.x - uv1.x) : (In.uv.y - uv1.y);
float distance2 = isHorizontal ? (uv2.x - In.uv.x) : (uv2.y - In.uv.y);

// ç¦»å“ªä¸ªç«¯ç‚¹æ›´è¿‘ï¼Ÿ
bool isDirection1 = distance1 < distance2;
float distanceFinal = min(distance1, distance2);

// çº¿æ®µæ€»é•¿åº¦
float edgeThickness = (distance1 + distance2);

// æ‰¾åˆ°
float pixelOffset = - distanceFinal / edgeThickness + 0.5;
{% endprism %}

è¿™é‡Œæœ‰ä¸€ç‚¹éœ€è¦æ³¨æ„ï¼Œä¸ºäº†é˜²æ­¢ è¿‘ç«¯ç‚¹äº®åº¦å¤§äºå‡å€¼è€Œä¸­å¿ƒäº®åº¦å°äºå‡å€¼è¿™ç§æƒ…å†µçš„å‡ºç°ï¼Œéœ€è¦ä¿è¯æ•´ä½“äº®åº¦å˜åŒ–æ–¹å‘ä¸€è‡´ã€‚å¦‚æœä¸ä¸€è‡´åˆ™ä¸åº”ç”¨åç§»é‡ï¼š
{% prism glsl linenos %}
// ä¸­å¿ƒå’Œå¹³å‡äº®åº¦æ¯”è¾ƒ
bool isLumaCenterSmaller = lumaCenter < lumaLocalAverage;

// è¿‘ç«¯ç‚¹ å’Œ ä¸­å¿ƒåˆ°å¹³å‡äº®åº¦çš„å˜åŒ–ä¸ä¸€è‡´
bool correctVariation = ((isDirection1 ? lumaEnd1 : lumaEnd2) < 0.0) != isLumaCenterSmaller;

// å¦‚æœä¸ä¸€è‡´åˆ™ä¸åº”ç”¨åç§»é‡
float finalOffset = correctVariation ? pixelOffset : 0.0;
{% endprism %}

### Subpixel antialiasing
å…³äº Sub-Pixel è¿™ç¯‡ã€Œ**Understanding Sub-Pixel (LCD Screen) Anti-Aliased Font Rendering**ã€[ğŸ”—](http://alienryderflex.com/sub_pixel/)
> The first circle just turns the whole RGB triplet completely on or completely off.
> The second circle varies the strength of each RGB triplet to generate intermediate shades of grey.
> But the third circle varies the strength of each display element separately to achieve the best possible rendition of a sharp-edged circle

![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2019/png/158945/1549078073047-6640228a-5f54-477e-9d6f-989ec06bebfa.png#align=left&display=inline&height=110&linkTarget=_blank&name=image.png&originHeight=220&originWidth=225&size=1921&width=113)![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2019/png/158945/1549078080701-c7252504-980f-4e72-8c0c-4c52aaa814b6.png#align=left&display=inline&height=110&linkTarget=_blank&name=image.png&originHeight=220&originWidth=227&size=2387&width=114)![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2019/png/158945/1549078061983-3bc1313e-f00d-4033-b999-232a04bbda08.png#align=left&display=inline&height=110&linkTarget=_blank&name=image.png&originHeight=220&originWidth=224&size=2479&width=112)<br />å¼€å¯åçš„æ•ˆæœå›¾ï¼š<br />![Antialias-vrs-Cromapixel.svg](https://intranetproxy.alipay.com/skylark/lark/0/2019/svg/158945/1549078233892-3f2f255d-768b-4ea1-b40c-665fb1233471.svg#align=left&display=inline&height=252&linkTarget=_blank&name=Antialias-vrs-Cromapixel.svg&originHeight=252&originWidth=400&size=217684&width=400)

the amount of sub-pixel aliasing removalï¼Œä¼šå½±å“é”åº¦ï¼š
{% prism glsl linenos %}
//   1.00 - upper limit (softer)
//   0.75 - default amount of filtering
//   0.50 - lower limit (sharper, less sub-pixel aliasing removal)
//   0.25 - almost off
//   0.00 - completely off
FxaaFloat fxaaQualitySubpix,
{% endprism %}

å– sub-pixel å’Œä¹‹å‰è®¡ç®—å‡ºçš„åç§»é‡çš„è¾ƒå¤§è€…ï¼š
{% prism glsl linenos %}
SUBPIXEL_QUALITY = 0.75 // fxaaQualitySubpix

// 3x3 neighborhoodï¼ŒåŠ æƒå¹³å‡ï¼ˆä¸Šä¸‹å·¦å³2ï¼Œå››ä¸ªè§’1ï¼‰
float lumaAverage = (1.0/12.0) * (2.0 * (lumaDownUp + lumaLeftRight) + lumaLeftCorners + lumaRightCorners);
// Ratio of the delta between the global average and the center luma, over the luma range in the 3x3 neighborhood.
float subPixelOffset1 = clamp(abs(lumaAverage - lumaCenter)/lumaRange,0.0,1.0);
float subPixelOffset2 = (-2.0 * subPixelOffset1 + 3.0) * subPixelOffset1 * subPixelOffset1;
// Compute a sub-pixel offset based on this delta.
float subPixelOffsetFinal = subPixelOffset2 * subPixelOffset2 * SUBPIXEL_QUALITY;

// Pick the biggest of the two offsets.
finalOffset = max(finalOffset,subPixelOffsetFinal);
{% endprism %}

## æœ€ç»ˆæ•ˆæœ
å–åç§»åçš„çº¹ç´ é¢œè‰²ä½œä¸ºæœ€ç»ˆè¾“å‡ºï¼š
{% prism glsl linenos %}
// è®¡ç®—åç§»é‡
vec2 finalUv = In.uv;
if(isHorizontal){
    finalUv.y += finalOffset * stepLength;
} else {
    finalUv.x += finalOffset * stepLength;
}

// å–åç§»åçš„çº¹ç´ è¾“å‡º
vec3 finalColor = texture(screenTexture,finalUv).rgb;
fragColor = finalColor;
{% endprism %}

ä¼˜ç‚¹å¾ˆæ˜æ˜¾ï¼Œå®ç°ç®€å•å¼€é”€å°ï¼ˆç›¸æ¯” SMAA æ‰€éœ€çš„ä¸‰ä¸ª passï¼ŒFXAA åªéœ€è¦ä¸€ä¸ªï¼‰ï¼Œä½†æ˜¯æ•ˆæœä¸æ˜¯ååˆ†ä¼˜ç§€ã€‚<br />![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2019/png/158945/1549025433974-8ec1ea74-c30b-4a9b-a850-112dfd4b0d96.png#align=left&display=inline&height=253&linkTarget=_blank&name=image.png&originHeight=956&originWidth=1452&size=66183&width=384)

ä»¥ä¸Šæ˜¯ nvidia åŸä½œè€…æå‡ºçš„ç¬¬ä¸€ç‰ˆ FXAA çš„å®ç°ï¼Œéšåä»–æå‡ºäº†ç›®å‰å¹¿ä¸ºä½¿ç”¨çš„ç¬¬ä¸‰ç‰ˆï¼Œä¹Ÿæ˜¯å¾ˆå¤šå¼•æ“ä¸­é‡‡ç”¨çš„ FXAA 3.xã€‚<br />

## FXAA çš„åç»­æ”¹è¿›
åœ¨é˜…è¯» clay.gl æºç æ—¶å‘ç°ç›®å‰ä½¿ç”¨çš„ fxaa å®ç°ç›¸å¯¹ç®€å•ï¼Œæ¥è‡ª glsl-fxaa [ğŸ”—](https://github.com/mattdesl/glsl-fxaa)
> A WebGL implementation of Fast Approximate Anti-Aliasing (FXAA v2). This is a screen-space technique. The code was originally fromÂ [Geeks3D.com](https://www.geeks3d.com/20110405/fxaa-fast-approximate-anti-aliasing-demo-glsl-opengl-test-radeon-geforce/3/)Â and cleaned up byÂ [Armin Ronacher](https://github.com/mitsuhiko/webgl-meincraft)Â for WebGL.


### dependent texture reads
<br /><br />åœ¨è¿™ä¸ªç‰ˆæœ¬çš„å®ç°ä¸­ï¼Œä»‹ç»åˆ°ä½¿ç”¨äº†ä¸€ç§ä¼˜åŒ–æ–¹å¼ï¼š
> This FXAA shader uses 9 **dependent texture reads**. For various mobile GPUs (particularly iOS), we can optimize the shader by making 5 of the texture2D calls **non-dependent**. To do this, the coordinates have to be computed in the vertex shader and passed along:

é‚£ä¹ˆå•¥æ˜¯Â **dependent texture reads **å‘¢ï¼Ÿæ¥è‡ª sf çš„ä¸€ä¸ªå›ç­”ï¼š<br />[https://stackoverflow.com/questions/1054096/what-is-a-dependent-texture-read](https://stackoverflow.com/questions/1054096/what-is-a-dependent-texture-read)
> An important implication is that the texture coordinates (where you look up from) is not determined until the middle of execution of the shader... there's no kind of static analysis you can do on the shader (even knowing the values of all parameters) that will tell you what the **coordinates will be ahead of time**


å› æ­¤ä¸ºäº†åœ¨ç¼–è¯‘æ—¶è€Œéè¿è¡Œæ—¶å°±çŸ¥é“è·å–çº¹ç†åæ ‡ï¼Œåœ¨ vs ä¸­è®¡ç®—å¥½ 4 ä¸ªé‚»å±…åæ ‡å¹¶é€šè¿‡ varying ä¼ é€’ç»™ fsï¼š
{% prism glsl linenos %}
// tex.vs

void texcoords(vec2 fragCoord, vec2 resolution,
			out vec2 v_rgbNW, out vec2 v_rgbNE,
			out vec2 v_rgbSW, out vec2 v_rgbSE,
			out vec2 v_rgbM) {
	vec2 inverseVP = 1.0 / resolution.xy;
	v_rgbNW = (fragCoord + vec2(-1.0, -1.0)) * inverseVP;
	v_rgbNE = (fragCoord + vec2(1.0, -1.0)) * inverseVP;
	v_rgbSW = (fragCoord + vec2(-1.0, 1.0)) * inverseVP;
	v_rgbSE = (fragCoord + vec2(1.0, 1.0)) * inverseVP;
	v_rgbM = vec2(fragCoord * inverseVP);
}

#pragma glslify: export(texcoords)
{% endprism %}

ä½†æ˜¯ä¸Šé¢é‚£ä¸ªé—®ç­”ä¸­ä¹Ÿæåˆ°äº†ï¼Œè¿™ç§è¿‡äºæ·±å…¥ç¡¬ä»¶ä½“å±‚å®ç°çš„ä¼˜åŒ–åœ¨æ–°æ¬¾ GPU ä¸­å·²ç»æ˜¯ä¸éœ€è¦çš„äº†ã€‚<br />æ¯•ç«Ÿ glsl-fxaa ä¹Ÿæ˜¯å†™äº 4ã€5 å¹´å‰çš„ï¼ŒåŒæ ·çš„è¿˜æœ‰ [https://github.com/mattdesl/three-shader-fxaa](https://github.com/mattdesl/three-shader-fxaa)ã€‚<br />ä¸‹é¢æ¥çœ‹çœ‹ FXAA 3.x çš„å®ç°æ–¹å¼ã€‚

### 3.x

ç”±äºåŸä½œè€…çš„åšå®¢å·²ç»å¤±æ•ˆäº†ï¼Œç›®å‰åªèƒ½æ‰¾åˆ°è¿™ä¸€ç¯‡å†å²æ–‡æ¡£ï¼š[http://archive.is/Y7Ns](http://archive.is/Y7Ns)ï¼Œå…¶ä¸­è¯´åˆ°ä½œè€…å®ç°äº†ç¬¬ä¸€ç‰ˆï¼ˆä¹Ÿå°±æ˜¯ä¸Šé¢çš„åŸºç¡€å®ç°ï¼‰ä¹‹åï¼Œåˆä¼˜åŒ–äº†ç¬¬äºŒã€ä¸‰ç‰ˆï¼Œä½†æ˜¯ç›®å‰æˆ‘åªæ‰¾åˆ°äº† FXAA3ï¼Œä¹Ÿå°±æ˜¯å½“å‰åº”ç”¨å¹¿æ³›çš„å®ç°ã€‚ä¸€å¼€å§‹å…‰çœ‹æ²¡æœ‰æ³¨é‡Šçš„æºç æœ‰äº›éš¾ä»¥ç†è§£ï¼Œç›´è§‚æ„Ÿè§‰å°±æ˜¯ç›¸è¾ƒäºç¬¬ä¸€ç‰ˆè¦ç²¾ç®€ä¸€äº›ã€‚åæ¥æ‰¾åˆ°äº†ä½œè€…åœ¨ SIGGRAPH 2011 ä¸Šçš„ä¸€ä»½ Slide [ğŸ”—](http://iryoku.com/aacourse/downloads/09-FXAA-3.11-in-15-Slides.pdf)ï¼Œå…¶ä¸­è¯¦ç»†ä»‹ç»äº†ç®—æ³•çš„æ€è·¯ï¼Œæ‰ç®—çœŸæ­£ç†è§£ã€‚

![å±å¹•å¿«ç…§ 2019-02-03 ä¸‹åˆ9.16.00.png](https://intranetproxy.alipay.com/skylark/lark/0/2019/png/158945/1549199780431-fdf1a8b6-b0a5-4ced-94d8-30c4c85581a2.png#align=left&display=inline&height=420&linkTarget=_blank&name=%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-03%20%E4%B8%8B%E5%8D%889.16.00.png&originHeight=1266&originWidth=2248&size=1149942&width=746)

é¦–å…ˆæŒ‰ç…§å›¾ä¸­å®šä¹‰çš„ 2 tap filterï¼Œx è½´æ–¹å‘éœ€è¦åå‘ã€‚<br />ç„¶åå– xy äº®åº¦å˜åŒ–å°çš„é‚£ä¸ªæ–¹å‘ï¼Œè¿›è¡Œç¼©æ”¾ã€‚<br />æœ€åé™å®š filter width ä¸º -8 åˆ° 8 ä¹‹é—´ã€‚
{% prism glsl linenos %}
mediump vec2 dir;
// x è½´æ–¹å‘éœ€è¦åå‘
dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));
dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));

float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *
	(0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);

// å–å¾— xy è¾ƒå°çš„å˜åŒ–æ–¹å‘è¿›è¡Œç¼©æ”¾
float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);

// filter width FXAA_SPAN_MAX = 8
dir = min(
	vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),
	max(
  	vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),
		dir * rcpDirMin // ç¼©æ”¾
  )
) * inverseVP;
{% endprism %}


![å±å¹•å¿«ç…§ 2019-02-03 ä¸‹åˆ9.13.39.png](https://intranetproxy.alipay.com/skylark/lark/0/2019/png/158945/1549199637086-2b160a4f-58a5-4f4c-a66a-e5a1193771e1.png#align=left&display=inline&height=422&linkTarget=_blank&name=%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-03%20%E4%B8%8B%E5%8D%889.13.39.png&originHeight=1268&originWidth=2244&size=761717&width=746)
> If fullâ€width filter width estimation is too large, then there is a chance the filter kernel
will sample from regions off the local edge.
In this case noise will be introduced by the filter kernel.
This step attempts to **remove this noise**.

é¡ºä¾¿æŠŠ subpixel åèµ°æ ·ä¹Ÿåšäº†ï¼Œå– 0ï¼Œ1/3ï¼Œ2/3 å’Œ 1 å¤„å››ä¸ªçš„çº¹ç´ ï¼š
{% prism glsl linenos %}
// 2-tap sub-pixel åèµ°æ · 1/3 å’Œ 2/3
vec3 rgbA = 0.5 * (
  texture2D(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz +
  texture2D(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);
// 4-tap å†åŠ ä¸Š 0 å’Œ 1
vec3 rgbB = rgbA * 0.5 + 0.25 * (
  texture2D(tex, fragCoord * inverseVP + dir * -0.5).xyz +
  texture2D(tex, fragCoord * inverseVP + dir * 0.5).xyz);

float lumaB = dot(rgbB, luma);
// å¦‚æœ 4-tap filter å¼•å…¥çš„å™ªå£°å¯¼è‡´è¶…å‡ºäº†äº®åº¦çš„èŒƒå›´ï¼Œåªè¿”å› 2-tap ç»“æœ
if ((lumaB < lumaMin) || (lumaB > lumaMax))
	color = vec4(rgbA, texColor.a);
else
	color = vec4(rgbB, texColor.a);
return color;
{% endprism %}

